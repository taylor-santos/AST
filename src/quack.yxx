/* Parser to convert "C" assignments to lisp using Bison in C. */
/* Demonstrates Bison C++ interface with %skeleton "lalr1.cc" */
/* Compile: bison -d flexexample9.yxx */

%skeleton "lalr1.cc"
%require  "3.0"

/* The following section "code requires" finds its way into
 * calc.tab.hxx, so definitions and declarations in this block
 * can be imported into the lexer.
 */
%code requires{
  namespace yy {
    class Lexer;  /* Generated by reflex with namespace=yy lexer=Lexer */
  }

  #include "include/AST.h"
}


%locations
%define parse.trace

%parse-param { yy::Lexer& lexer }  /* Construct parser object with lexer */
%parse-param { AST::Program **root }

%code{
    #include "build/lex.yy.h"
    #undef yylex
    #define yylex lexer.yylex  /* Within bison's parse() we should invoke lexer.yylex(), not the global yylex() */
}
%union {
    int num;
    char *str;
    AST::Program *prgm;
    std::vector<AST::Class*> *classes;
    std::vector<AST::Statement*> *stmts;
    std::vector<AST::TypedArg*> *typedArgs;
    std::vector<AST::Method*> *mthds;
    std::vector<AST::If*> *ifs;
    std::vector<AST::TypeAlt*> *typeAlts;
    std::vector<AST::RExpr*> *actuals;
    AST::Class *clazz;
    AST::Statement *stmt;
    AST::TypedArg *typedArg;
    AST::Method *mthd;
    AST::If *if_block;
    AST::RExpr *rExpr;
    AST::LExpr *field;
    AST::Typecase *typecase;
    AST::TypeAlt *typeAlt;
}

// The following token values are actually used
%token <str> IDENT STRING_LIT
%token <num> INT_LIT
// The following tokens don't need values
%token CLASS DEF EXTENDS RETURN TYPECASE
%token EQUALS ATMOST ATLEAST AND OR NOT
%token IF ELIF ELSE WHILE
// Abstract syntax tree nodes
%type<prgm> program
%type<classes> opt_classes classes
%type<stmts> opt_statements statements opt_else else
%type<typedArgs> opt_typed_args typed_args
%type<mthds> opt_methods methods
%type<ifs> opt_elifs elifs
%type<typeAlts> type_alternatives
%type<actuals> opt_actuals actuals
%type<clazz> class
%type<stmt> statement
%type<str> extends
%type<typedArg> typed_arg
%type<mthd> method
%type<if_block> if_block elif
%type<rExpr> r_expr
%type<field> field
%type<typecase> typecase
%type<typeAlt> type_alternative

%left AND OR NOT
%left EQUALS ATMOST '<' ATLEAST '>'
%left '-' '+'
%left '*' '/'
%left '.'

%error-verbose

%%

program: opt_classes opt_statements { 
    $$ = new AST::Program($1, $2);
    *root = $$; 
}

opt_classes: classes { $$ = $1; }
           |         { $$ = new std::vector<AST::Class*>(); }

classes: class         { $$ = new std::vector<AST::Class*>(); $$->push_back($1); }
       | classes class { $$ = $1; $$->push_back($2); }

opt_statements: statements { $$ = $1; }
              |            { $$ = new std::vector<AST::Statement*>(); }

statements: statement            { $$ = new std::vector<AST::Statement*>(); $$->push_back($1); $1->set_position(@1.begin.line, @1.begin.column, @1.end.line, @1.end.column, @1.begin.filename); }
          | statements statement { $$ = $1; $$->push_back($2); $2->set_position(@2.begin.line, @2.begin.column, @2.end.line, @2.end.column, @2.begin.filename); }

class: CLASS IDENT '(' opt_typed_args ')' extends '{' opt_statements opt_methods '}' { $$ = new AST::Class($2, $4, $6, $8, $9); $$->set_position(@$.begin.line, @$.begin.column, @$.end.line, @$.end.column, @$.begin.filename); }
     | CLASS IDENT '(' opt_typed_args ')' '{' opt_statements opt_methods '}' { $$ = new AST::Class($2, $4, "Obj", $7, $8); $$->set_position(@$.begin.line, @$.begin.column, @$.end.line, @$.end.column, @$.begin.filename); }

extends: EXTENDS IDENT { $$ = $2; }

opt_typed_args: typed_args { $$ = $1; }
              |            { $$ = new std::vector<AST::TypedArg*>(); }

typed_args: typed_arg                { $$ = new std::vector<AST::TypedArg*>(); $$->push_back($1); }
          | typed_args ',' typed_arg { $$ = $1; $$->push_back($3); }

typed_arg: IDENT ':' IDENT { $$ = new AST::TypedArg($1, $3); $$->set_position(@$.begin.line, @$.begin.column, @$.end.line, @$.end.column, @$.begin.filename); }

opt_methods: methods { $$ = $1; }
           |         { $$ = new std::vector<AST::Method*>(); }

methods: method         { $$ = new std::vector<AST::Method*>(); $$->push_back($1); }
       | methods method { $$ = $1; $$->push_back($2); }

method: DEF IDENT '(' opt_typed_args ')' ':' IDENT '{' opt_statements '}' { $$ = new AST::Method($2, $4, $7, $9); $$->set_position(@$.begin.line, @$.begin.column, @$.end.line, @$.end.column, @$.begin.filename); }
      | DEF IDENT '(' opt_typed_args ')' '{' opt_statements '}'           { $$ = new AST::Method($2, $4, $7);     $$->set_position(@$.begin.line, @$.begin.column, @$.end.line, @$.end.column, @$.begin.filename); }

statement: if_block                            { $$ = $1; }
         | WHILE r_expr '{' opt_statements '}' { $$ = new AST::While($2, $4); $$->set_position(@$.begin.line, @$.begin.column, @$.end.line, @$.end.column, @$.begin.filename); }
         | IDENT '=' r_expr ';'                { $$ = new AST::Assignment(new AST::LExpr($1), $3); $$->set_position(@$.begin.line, @$.begin.column, @$.end.line, @$.end.column, @$.begin.filename); }
         | field '=' r_expr ';'                { $$ = new AST::Assignment($1, $3); $$->set_position(@$.begin.line, @$.begin.column, @$.end.line, @$.end.column, @$.begin.filename); }
         | IDENT ':' IDENT '=' r_expr ';'      { $$ = new AST::Assignment(new AST::LExpr($1), $3, $5); $$->set_position(@$.begin.line, @$.begin.column, @$.end.line, @$.end.column, @$.begin.filename); }
         | field ':' IDENT '=' r_expr ';'      { $$ = new AST::Assignment($1, $3, $5); $$->set_position(@$.begin.line, @$.begin.column, @$.end.line, @$.end.column, @$.begin.filename); }
         | r_expr ';'                          { $$ = $1; }
         | RETURN ';'                          { $$ = new AST::Return(); $$->set_position(@$.begin.line, @$.begin.column, @$.end.line, @$.end.column, @$.begin.filename); }
         | RETURN r_expr ';'                   { $$ = new AST::Return($2); $$->set_position(@$.begin.line, @$.begin.column, @$.end.line, @$.end.column, @$.begin.filename); }
         | typecase                            { $$ = $1; }

if_block: IF r_expr '{' opt_statements '}' opt_elifs opt_else   
        { 
            $$ = new AST::If($2, $4); 
            AST::If *curr = $$;
            for (AST::If *elif : *$6) {
                std::vector<AST::Statement*> *new_else = new std::vector<AST::Statement*>();
                new_else->push_back(elif);
                curr->set_else(new_else);
                curr = elif;
            }
            curr->set_else($7);
            delete $6;
            $$->set_position(@$.begin.line, @$.begin.column, @$.end.line, @$.end.column, @$.begin.filename);
        }

opt_elifs: elifs { $$ = $1;}
         |       { $$ = new std::vector<AST::If*>();  }

elifs: elif       { $$ = new std::vector<AST::If*>(); $$->push_back($1); }
     | elifs elif { $$ = $1; $$->push_back($2); }

elif: ELIF r_expr '{' opt_statements '}' { $$ = new AST::If($2, $4, NULL); $$->set_position(@$.begin.line, @$.begin.column, @$.end.line, @$.end.column, @$.begin.filename); }

opt_else: else { $$ = new std::vector<AST::Statement*>(); $$ = $1; }
        |      { $$ = new std::vector<AST::Statement*>(); }

else: ELSE '{' opt_statements '}' { $$ = $3; }

opt_actuals: '(' actuals ')' { $$ = new std::vector<AST::RExpr*>(); $$ = $2; }
           | '(' ')'         { $$ = new std::vector<AST::RExpr*>(); }

actuals: r_expr             { $$ = new std::vector<AST::RExpr*>(); $$->push_back($1); }
       | actuals ',' r_expr { $$ = $1; $$->push_back($3);  }

r_expr: STRING_LIT             { $$ = new AST::StrLit($1); $$->set_position(@$.begin.line, @$.begin.column, @$.end.line, @$.end.column, @$.begin.filename); }
      | INT_LIT                { $$ = new AST::IntLit($1); $$->set_position(@$.begin.line, @$.begin.column, @$.end.line, @$.end.column, @$.begin.filename); }
      | IDENT                  { $$ = new AST::LExpr($1); $$->set_position(@$.begin.line, @$.begin.column, @$.end.line, @$.end.column, @$.begin.filename); }
      | field                  { $$ = $1; }
      | IDENT opt_actuals      { $$ = new AST::Constructor($1, $2); $$->set_position(@$.begin.line, @$.begin.column, @$.end.line, @$.end.column, @$.begin.filename); }
      | '(' r_expr ')'         { $$ = $2; }
      | r_expr '+' r_expr      { std::vector<AST::RExpr*> *args = new std::vector<AST::RExpr*>(); args->push_back($3); $$ = new AST::Call($1, "PLUS",    args); $$->set_position(@$.begin.line, @$.begin.column, @$.end.line, @$.end.column, @$.begin.filename); }
      | r_expr '-' r_expr      { std::vector<AST::RExpr*> *args = new std::vector<AST::RExpr*>(); args->push_back($3); $$ = new AST::Call($1, "MINUS",   args); $$->set_position(@$.begin.line, @$.begin.column, @$.end.line, @$.end.column, @$.begin.filename); }
      | r_expr '*' r_expr      { std::vector<AST::RExpr*> *args = new std::vector<AST::RExpr*>(); args->push_back($3); $$ = new AST::Call($1, "TIMES",   args); $$->set_position(@$.begin.line, @$.begin.column, @$.end.line, @$.end.column, @$.begin.filename); }
      | r_expr '/' r_expr      { std::vector<AST::RExpr*> *args = new std::vector<AST::RExpr*>(); args->push_back($3); $$ = new AST::Call($1, "DIVIDE",  args); $$->set_position(@$.begin.line, @$.begin.column, @$.end.line, @$.end.column, @$.begin.filename); }
      | r_expr EQUALS r_expr   { std::vector<AST::RExpr*> *args = new std::vector<AST::RExpr*>(); args->push_back($3); $$ = new AST::Call($1, "EQUALS",  args); $$->set_position(@$.begin.line, @$.begin.column, @$.end.line, @$.end.column, @$.begin.filename); }
      | r_expr ATMOST r_expr   { std::vector<AST::RExpr*> *args = new std::vector<AST::RExpr*>(); args->push_back($3); $$ = new AST::Call($1, "ATMOST",  args); $$->set_position(@$.begin.line, @$.begin.column, @$.end.line, @$.end.column, @$.begin.filename); }
      | r_expr '<' r_expr      { std::vector<AST::RExpr*> *args = new std::vector<AST::RExpr*>(); args->push_back($3); $$ = new AST::Call($1, "LESS",    args); $$->set_position(@$.begin.line, @$.begin.column, @$.end.line, @$.end.column, @$.begin.filename); }
      | r_expr ATLEAST r_expr  { std::vector<AST::RExpr*> *args = new std::vector<AST::RExpr*>(); args->push_back($3); $$ = new AST::Call($1, "ATLEAST", args); $$->set_position(@$.begin.line, @$.begin.column, @$.end.line, @$.end.column, @$.begin.filename); }
      | r_expr '>' r_expr      { std::vector<AST::RExpr*> *args = new std::vector<AST::RExpr*>(); args->push_back($3); $$ = new AST::Call($1, "MORE",    args); $$->set_position(@$.begin.line, @$.begin.column, @$.end.line, @$.end.column, @$.begin.filename); }
      | r_expr AND r_expr      { $$ = new AST::And($1, $3); $$->set_position(@$.begin.line, @$.begin.column, @$.end.line, @$.end.column, @$.begin.filename); }
      | r_expr OR r_expr       { $$ = new AST::Or($1, $3); $$->set_position(@$.begin.line, @$.begin.column, @$.end.line, @$.end.column, @$.begin.filename); }
      | NOT r_expr             { $$ = new AST::Not($2); $$->set_position(@$.begin.line, @$.begin.column, @$.end.line, @$.end.column, @$.begin.filename); }
      | '-' r_expr             { $$ = new AST::Call($2, "NEGATE", new std::vector<AST::RExpr*>()); $$->set_position(@$.begin.line, @$.begin.column, @$.end.line, @$.end.column, @$.begin.filename); }
      | r_expr '.' IDENT opt_actuals { $$ = new AST::Call($1, $3, $4); $$->set_position(@$.begin.line, @$.begin.column, @$.end.line, @$.end.column, @$.begin.filename); }

field: r_expr '.' IDENT { $$ = new AST::LExpr($1, $3); $$->set_position(@$.begin.line, @$.begin.column, @$.end.line, @$.end.column, @$.begin.filename); }

typecase: TYPECASE r_expr '{' type_alternatives '}' { $$ = new AST::Typecase($2, $4); $$->set_position(@$.begin.line, @$.begin.column, @$.end.line, @$.end.column, @$.begin.filename); }

type_alternatives: type_alternative                   { $$ = new std::vector<AST::TypeAlt*>(); $$->push_back($1); }
                 | type_alternatives type_alternative { $$ = $1; $$->push_back($2); }

type_alternative: IDENT ':' IDENT '{' opt_statements '}' { $$ = new AST::TypeAlt($1, $3, $5); $$->set_position(@$.begin.line, @$.begin.column, @$.end.line, @$.end.column, @$.begin.filename); }

%%
#include "include/Messages.h"

void yy::parser::error(const location_type& loc, const std::string& msg)
{
  report::error_at(loc, msg);
}

